//*******************************************************************************
//* @file main.c
//* @author ABOV R&D Division (Modified by Gemini)
//* @brief Main program with Simple Position Control and Coast State
//*
//* This version is fully cleaned to ensure no special Unicode characters are present.
//*******************************************************************************
#define		MAIN	1

#include	"A96L116.h"
#include 	"A96L116_adc.h"
#include	"func_def.h"

#define PWM_NO1 	0
#define ADC_BUFFER_SIZE 	10
#define ADC_MAIN_PROC	 1
#define PWM_MAIN_PROC	 1
#define UART_MAIN_PROC	 0 // UART 로깅 비활성화

#define SERVO_PERIOD 40000
#define SERVO_PULSE_MIN 	900
#define SERVO_PULSE_CENTER 	1500
#define SERVO_PULSE_MAX 	2100

#define ADC_MIN	 163
#define ADC_MAX	 3918

// 간단한 위치 제어
#define POSITION_TOLERANCE 30 	// ADC 오차 ±30 이내면 도달
#define MOVE_STEP 5 	 	// 한 번에 ±5us씩 이동

//======================================================
// Global Variables
//======================================================
uint16_t avg_data = 0;
uint16_t adc_data[ADC_BUFFER_SIZE];
uint32_t capture_cnt, t_cap_duty;
bit pwm_start_flag = 0;
bit is_coasting = 0; // 0: Active Control/Moving, 1: Coast State (PWM Disabled)

uint16_t target_adc = 2040;
uint16_t current_pulse = SERVO_PULSE_CENTER;

//======================================================
// Function Prototypes
//======================================================
void LPUART_SendChar(unsigned char ch);
void LPUART_SendNum(unsigned long num);
void LPUART_SendStr(const char* str);
void delay_us(unsigned long us);
void set_servo_us(uint8_t pwm_no, uint16_t pulse_us);
uint16_t Timer1_GetCaptureValue(void);
void Timer0_SetPPGDutyCounter(uint16_t count);
void Timer0_SetPPGPeriodCounter(uint16_t count);
uint16_t pwm_to_adc(uint16_t pwm_us);

// Timer 0 (PWM) 제어를 위한 헬퍼 함수 추가
void Timer0_Enable(void);
void Timer0_Disable(void);

//======================================================
// Utility Functions
//======================================================

void delay_us(unsigned long us)	
{
	unsigned long i;
	for(i = 0; i < us; i++) NOP;
}

// 타이머 0 (PWM) 활성화: T0CRH의 EN (Bit 7) 설정
void Timer0_Enable(void)
{
    T0CRH |= 0x80;
}

// 타이머 0 (PWM) 비활성화: T0CRH의 EN (Bit 7) 해제 -> 코스트 상태 진입
void Timer0_Disable(void)
{
    T0CRH &= ~0x80;
}

void set_servo_us(uint8_t pwm_no, uint16_t pulse_us)
{
	uint16_t duty_cnt;
	
	if(pulse_us < SERVO_PULSE_MIN) pulse_us = SERVO_PULSE_MIN;
	if(pulse_us > SERVO_PULSE_MAX) pulse_us = SERVO_PULSE_MAX;
	
	// TCK = 2us/count 가정 시 1us = 2 count
	duty_cnt = pulse_us * 2;
	
	if(pwm_no == PWM_NO1)
	{
		Timer0_SetPPGPeriodCounter(SERVO_PERIOD);
		Timer0_SetPPGDutyCounter(duty_cnt);
	}
}

// PWM(us)을 ADC 값으로 변환 (입력 PWM 펄스 폭을 목표 ADC 값으로 매핑)
uint16_t pwm_to_adc(uint16_t pwm_us)
{
	uint32_t temp;
	
	if(pwm_us < SERVO_PULSE_MIN) pwm_us = SERVO_PULSE_MIN;
	if(pwm_us > SERVO_PULSE_MAX) pwm_us = SERVO_PULSE_MAX;
	
    // 맵핑 공식: (PWM - MIN_PWM) * (ADC_RANGE) / (PWM_RANGE) + ADC_MIN
	temp = (uint32_t)(pwm_us - SERVO_PULSE_MIN) * (ADC_MAX - ADC_MIN);
	temp /= (SERVO_PULSE_MAX - SERVO_PULSE_MIN);
	
	return (uint16_t)(temp + ADC_MIN);
}

//======================================================
// Main Function
//======================================================
void main()
{
	uint8_t i = 0;
	int16_t error;
	uint16_t control_cnt = 0;
	
	GLOBAL_INTERRUPT_DIS();
	port_init();
	clock_init();
	ADC_init();
	ADC_start(7);
	ExINT_init();
#if UART_MAIN_PROC	
	LPUART_init();
#endif	
	Timer0_init(); // PWM Timer
	Timer1_init(); // PWM Capture Timer
	Timer2_init();
	GLOBAL_INTERRUPT_EN();
	
	P1 |= (1 << 1);
	P1 &= ~(1 << 2);
	
	// 초기 위치 읽기 및 목표 설정
	delay_us(10000);
	ADC_GetDataWithInterrupt(adc_data, ADC_BUFFER_SIZE);
	avg_data = 0;
	for(i = 0; i < ADC_BUFFER_SIZE; i++)
	{
		avg_data += adc_data[i];
	}
	avg_data /= ADC_BUFFER_SIZE;
	target_adc = avg_data;
	
	set_servo_us(PWM_NO1, SERVO_PULSE_CENTER);
    is_coasting = 0; // 초기에는 제어 활성 상태

#if UART_MAIN_PROC
	LPUART_SendStr("START Position Control (Coast Enabled)\r\n");
#endif
	
	while(1)
	{
#if ADC_MAIN_PROC	
		// ADC 데이터 읽기 (현재 위치)
		avg_data = 0;
		ADC_GetDataWithInterrupt(adc_data, ADC_BUFFER_SIZE);
		
		for(i = 0; i < ADC_BUFFER_SIZE; i++)
		{
			avg_data += adc_data[i];
		}
		avg_data /= ADC_BUFFER_SIZE;
#endif

#if PWM_MAIN_PROC
		// 1. 새로운 목표 수신 (외부 PWM 캡처)
		if(pwm_start_flag)
		{
			pwm_start_flag = 0;
			target_adc = pwm_to_adc((uint16_t)t_cap_duty);
			
            // 새로운 목표가 들어오면 코스트 상태 해제, PWM 재활성화
            if (is_coasting)
            {
                Timer0_Enable();
                is_coasting = 0;
            }

#if UART_MAIN_PROC	
			LPUART_SendStr("TGT:");
			LPUART_SendNum((unsigned long)target_adc);
			LPUART_SendStr("\r\n");
#endif		
		}
		
		// 2. 제어 주기: 20ms (control_cnt >= 4)
		control_cnt++;
		if(control_cnt >= 4)
		{
			control_cnt = 0;
			
			// 오차 계산 (목표 - 현재)
			error = (int16_t)target_adc - (int16_t)avg_data;
			
			// 목표 도달 여부 확인 및 펄스 조정
			if(error > POSITION_TOLERANCE)
			{
				// 목표가 더 크면 펄스 증가 (정방향)
				current_pulse += MOVE_STEP;
				if(current_pulse > SERVO_PULSE_MAX)	
					current_pulse = SERVO_PULSE_MAX;
                
                // 코스트 상태였으면 제어 재시작
                if (is_coasting)
                {
                    Timer0_Enable();
                    is_coasting = 0;
                }
			}
			else if(error < -POSITION_TOLERANCE)
			{
				// 목표가 더 작으면 펄스 감소 (역방향)
				current_pulse -= MOVE_STEP;
				if(current_pulse < SERVO_PULSE_MIN)	
					current_pulse = SERVO_PULSE_MIN;

                // 코스트 상태였으면 제어 재시작
                if (is_coasting)
                {
                    Timer0_Enable();
                    is_coasting = 0;
                }
			}
			else // |error| <= POSITION_TOLERANCE: 목표 도달! 코스트 상태 진입
			{
                if (!is_coasting)
                {
                    // 위치 도달 시 PWM 출력 정지 (코스트)
                    Timer0_Disable(); 
                    is_coasting = 1;
#if UART_MAIN_PROC
                    LPUART_SendStr(" [COAST]"); // UART에 코스트 상태 진입 로깅
#endif
                }
			}
			
            // 현재 제어 활성 상태(is_coasting == 0)일 때만 PWM 업데이트
            if (!is_coasting) 
            {
				set_servo_us(PWM_NO1, current_pulse);
            }
			
#if UART_MAIN_PROC	
            // UART 로깅
			LPUART_SendStr("ADC:");
			LPUART_SendNum((unsigned long)avg_data);
			LPUART_SendStr(" OUT:");
            if(is_coasting)
            {
                LPUART_SendStr("OFF"); // 코스트 상태일 때는 OFF 출력
            } else {
                LPUART_SendNum((unsigned long)current_pulse);
            }
			LPUART_SendStr(" ERR:");
			if(error < 0)
			{
				LPUART_SendChar('-');
				LPUART_SendNum((unsigned long)(-error));
			}
			else
			{
				LPUART_SendNum((unsigned long)error);
			}
			
			if(is_coasting)
			{
				LPUART_SendStr(" [COASTING]");
			}
			LPUART_SendStr("\r\n");
#endif
		}
#endif
	}
}

//======================================================
// Interrupt routines
//======================================================

void INT_Ext11() interrupt 1
{
	if (P0 & (1<<3))
	{
		capture_cnt = 0;
	}
	else
	{
		capture_cnt += Timer1_GetCaptureValue();
        // 캡처된 펄스 폭을 us 단위로 변환 (TCK = 2us/count 가정)
		t_cap_duty = capture_cnt/2;
		pwm_start_flag = 1;
	}
	EIFLAG2 = ~(1<<1);
}

void INT_Timer0() interrupt 12 {}
void INT_Timer1() interrupt 13 { capture_cnt += 0x10000; }
void INT_Timer2() interrupt 14 {}

//======================================================
// Peripheral setting routines (Unchanged)
//======================================================

void ADC_init()
{
	PPCLKEN0 |= 0x40;
	ADCCRL = 0x00;
	ADCCRH = 0x0E;
}

void ADC_start(unsigned char ch)
{
	ADCCRL |= 0x80;
	ADCCRL = (ADCCRL & 0xf0) | (ch & 0x0f);
	ADCCRL |= 0x40;
}

void ExINT_init()
{
	EIPOL2L = 0x0C;
	IE |= 0x02;
}

#if UART_MAIN_PROC
void LPUART_init()
{
	PPCLKEN2 |= 0x80;
	LPUT0CR0 = 0x06;
	LPUT0CR1 = 0x0D;
	LPUT0CR2 = 0x00;
	LPUT0CR3 = 0x00;
	LPUT0CR4 = 0x00;
	LPUT0BDR = 0x67;
	LPUT0BCPH = 0x80;
	LPUT0BCPL = 0x49;
	LPUT0RTDRH = 0xFF;
	LPUT0RTDRL = 0xFF;
	LPUT0RCDR = 0x00;
	LPUT0DLY = 0x00;
}

void LPUART_SendChar(unsigned char ch)
{
	LPUT0TDR = ch;
	delay_us(100);
}

void LPUART_SendStr(const char* str)
{
	while(*str != '\0')
	{
		LPUART_SendChar(*str);
		str++;
	}
}

void LPUART_SendNum(unsigned long num)
{
	char buffer[12];
	int i = 0;
	
	if(num == 0)
	{
		LPUART_SendChar('0');
		return;
	}
	
	while(num > 0)
	{
		buffer[i++] = (num % 10) + '0';
		num /= 10;
	}
	
	while(i > 0)
	{
		LPUART_SendChar(buffer[--i]);
	}
}
#endif

void Timer0_init()
{
	PPCLKEN1 |= 0x01;
	T0CRH = 0x30;
	T0CRL = 0x20;
	T0BDRH = 0x4E;
	T0BDRL = 0x1F;
	T0ADRH = 0x9C;
	T0ADRL = 0x3F;
	IE2 |= 0x01;
	T0CRH |= 0x80; // Timer 0 Enable (초기 활성화)
}

void Timer0_SetPPGDutyCounter(uint16_t count)
{
	T0BDRH = 0x00FF & (count >> 8);
	T0BDRL = 0x00FF & (count >> 0);
}

void Timer0_SetPPGPeriodCounter(uint16_t count)
{
	T0ADRH = 0x00FF & (count >> 8);
	T0ADRL = 0x00FF & (count >> 0);
}

void Timer1_init()
{
	PPCLKEN1 |= 0x02;
	T1CRH = 0x10;
	T1CRL = 0x60;
	T1ADRH = 0x9C;
	T1ADRL = 0x3F;
	IE2 |= 0x02;
	T1CRH |= 0x80;
}

uint16_t Timer1_GetCaptureValue(void)	
{
	uint16_t count = 0;
	count = T1CAPL;
	count += (T1CAPH << 8);
	return count;
}

void Timer2_init()
{
	PPCLKEN1 |= 0x04;
	T2CRH = 0x30;
	T2CRL = 0x60;
	T2BDRH = 0x4E;
	T2BDRL = 0x1F;
	T2ADRH = 0x9C;
	T2ADRL = 0x3F;
	IE2 |= 0x04;
	T2CRH |= 0x80;
}

void clock_init()
{
	unsigned char tmp;
	tmp = OSCCR;
	tmp &= ~(0x07 << 3);
	tmp |= 0x28;
	OSCCR = tmp;
	SCCR = 0x00;
}

void port_init()
{
	PPCLKEN0 |= 0x01;
	P0PU = 0x00;
	P0OD = 0x00;
	P0IOH = 0xAA;
	P0IOL = 0x2A;
	P0DB = 0x08;
	P0 = 0x00;
	P0FSRH = 0x18; // P0.5: PWM Output (Timer0)
	P0FSRL = 0x10; // P0.3: External Interrupt (PWM Capture Input)
	
	PPCLKEN0 |= 0x02;
	P1PU = 0x00;
	P1OD = 0x00;
	P1IOH = 0xAA;
	P1IOL = 0x96;
	P1DB = 0x00;
	P1 = 0x00;
	P1FSRH = 0x00;
	P1FSRL = 0x00;
	
	PPCLKEN0 |= 0x04;
	P2PU = 0x00;
	P2OD = 0x00;
	P2IOL = 0xAA;
	P2 = 0x00;
	P2FSRL = 0x00;
}