C51 COMPILER V9.60.7.0   MAIN                                                              11/09/2025 17:18:29 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Users\compro\AppData\Local\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG O
                    -BJECTEXTEND TABS(2)

line level    source

   1          //**
   2          //*******************************************************************************
   3          //* @file main.c
   4          //* @author ABOV R&D Division
   5          //* @brief Main program
   6          //*
   7          //* Copyright 2022 ABOV Semiconductor Co.,Ltd. All rights reserved.
   8          //*
   9          //* This file is licensed under terms that are found in the LICENSE file
  10          //* located at Document directory.
  11          //* If this file is delivered or shared without applicable license terms,
  12          //* the terms of the BSD-3-Clause license shall be applied.
  13          //* Reference: https://opensource.org/licenses/BSD-3-Clause
  14          //*******************************************************************************
  15          //======================================================
  16          // Main program routine
  17          // - Device name  : A96L116
  18          // - Package type : 20TSSOP
  19          // Generated    : Sun, Nov 09, 2025 (12:31:50)
  20          //======================================================
  21          // MAIN is used for XDATA variable : V1.041.00 ~
  22          #define   MAIN  1 // Do not delete this line
  23          
  24          #include  "A96L116.h"
  25          #include  "A96L116_adc.h"
  26          #include  "func_def.h"
  27          
  28          #define PWM_NO1     0
  29          #define PWM_NO2     1
  30          
  31          #define ADC_BUFFER_SIZE     10
  32          
  33          #define ADC_MAIN_PROC  1
  34          #define PWM_MAIN_PROC  0
  35          #define UART_MAIN_PROC   1
  36          
  37          #define SERVO_FREQ  50          // 50Hz (20ms 주기)
  38          #define SERVO_PERIOD 40000      // 2MHz / 50Hz = 40,000 카운트 (20ms)
  39          
  40          #define SERVO_PULSE_MIN     900
  41          #define SERVO_PULSE_CENTER  1500
  42          #define SERVO_PULSE_MAX     2100
  43          
  44          uint16_t avg_data = 0;
  45          uint16_t adc_data[ADC_BUFFER_SIZE];
  46          
  47          uint32_t capture_cnt, t_cap_duty;
  48          bit pwm_start_flag = 0;
  49          
  50          void LPUART_SendChar(unsigned char ch);
  51          void LPUART_SendStr(const char* str);
  52          void LPUART_SendNum(unsigned long num);
  53          void delay_us(unsigned long us);
  54          
C51 COMPILER V9.60.7.0   MAIN                                                              11/09/2025 17:18:29 PAGE 2   

  55          void set_servo_us(uint8_t pwm_no,uint16_t pulse_us);
  56          
  57          uint16_t Timer1_GetCaptureValue(void);
  58          
  59          void Timer0_SetPPGDutyCounter(uint16_t count);
  60          void Timer0_SetPPGPeriodCounter(uint16_t count);
  61          
  62          void delay_us(unsigned long us)  
  63          {
  64   1          unsigned long i;
  65   1          for(i = 0; i < us; i++)
  66   1          {
  67   2              NOP;  
  68   2          }
  69   1      }
  70          
  71          void set_servo_us(uint8_t pwm_no,uint16_t pulse_us)
  72          {
  73   1        uint16_t p_cnt = SERVO_PERIOD;
  74   1          uint16_t duty_cnt;
  75   1      
  76   1        if(pulse_us < SERVO_PULSE_MIN) pulse_us = SERVO_PULSE_MIN;
  77   1          if(pulse_us > SERVO_PULSE_MAX) pulse_us = SERVO_PULSE_MAX;
  78   1      
  79   1          duty_cnt = pulse_us * 2;
  80   1        
  81   1        if(pwm_no == PWM_NO1)
  82   1        {
  83   2          Timer0_SetPPGPeriodCounter(p_cnt);
  84   2          Timer0_SetPPGDutyCounter(duty_cnt); 
  85   2        }
  86   1        else
  87   1        {
  88   2          //Timer0_SetPPGPeriodCounter(p_cnt);
  89   2          //Timer0_SetPPGDutyCounter(duty_cnt); 
  90   2        } 
  91   1      }
  92          
  93          void main()
  94          {
  95   1        uint8_t i = 0;
  96   1        uint32_t t_cap_duty_cpy = 0;
  97   1        
  98   1        GLOBAL_INTERRUPT_DIS();           
  99   1        port_init();      // initialize ports
 100   1        clock_init();     // initialize operation clock
 101   1        ADC_init();       // initialize A/D convertor
 102   1        ADC_start(7);
 103   1        ExINT_init();     // initialize external interrupt
 104   1      #if UART_MAIN_PROC  
 105   1        LPUART_init();    // initialize LPUART
 106   1      #endif  
 107   1        Timer0_init();    // initialize Timer0
 108   1        Timer1_init();    // initialize Timer1
 109   1        Timer2_init();    // initialize Timer2
 110   1        GLOBAL_INTERRUPT_EN();            
 111   1        
 112   1        // TODO: add your main code here
 113   1        P1 |= (1 << 1);     // HIGH P1.1 
 114   1        P1 &= ~(1 << 2);    // LOW  P1.2
 115   1        
 116   1        set_servo_us(PWM_NO1,900);
C51 COMPILER V9.60.7.0   MAIN                                                              11/09/2025 17:18:29 PAGE 3   

 117   1        
 118   1        while(1)
 119   1        {
 120   2          #if ADC_MAIN_PROC 
 121   2            avg_data = 0;
 122   2            ADC_GetDataWithInterrupt(adc_data, ADC_BUFFER_SIZE);    
 123   2            
 124   2            for(i = 0; i < ADC_BUFFER_SIZE; i++)
 125   2            {  
 126   3              avg_data += adc_data[i];
 127   3            }
 128   2            avg_data /= ADC_BUFFER_SIZE;
 129   2          #if UART_MAIN_PROC  
 130   2            LPUART_SendNum((unsigned long)avg_data);
 131   2            LPUART_SendChar(0x0D);
 132   2            LPUART_SendChar(0x0A);
 133   2            delay_us(1000);
 134   2          #endif
 135   2          #endif
 136   2          #if PWM_MAIN_PROC
                    if(pwm_start_flag)
                    {
                      
                      t_cap_duty_cpy = t_cap_duty;  
                      //LPUART_SendNum((unsigned long)t_cap_duty);
                      //LPUART_SendChar(0x0D);
                      //LPUART_SendChar(0x0A);
                      pwm_start_flag = 0;
                    }
                  #endif
 147   2        }
 148   1      }
 149          
 150          //======================================================
 151          // Interrupt routines
 152          //======================================================
 153          
 154          void INT_Ext11() interrupt 1
 155          {
 156   1        // External interrupt 11
 157   1        // TODO: add your code here
 158   1        if (P0 & (1<<3))
 159   1        {
 160   2          capture_cnt = 0;    
 161   2        }
 162   1        else
 163   1        {
 164   2          capture_cnt += Timer1_GetCaptureValue();
 165   2          t_cap_duty = capture_cnt/2;
 166   2      
 167   2          pwm_start_flag = 1;
 168   2        }
 169   1        EIFLAG2 = ~(1<<1);
 170   1      }
 171          
 172          void INT_Timer0() interrupt 12
 173          {
 174   1        // Timer0 interrupt
 175   1        // TODO: add your code here
 176   1      }
 177          
 178          void INT_Timer1() interrupt 13
C51 COMPILER V9.60.7.0   MAIN                                                              11/09/2025 17:18:29 PAGE 4   

 179          {
 180   1        // Timer1 interrupt
 181   1        // TODO: add your code here
 182   1        capture_cnt += 0x10000; 
 183   1      }
 184          
 185          void INT_Timer2() interrupt 14
 186          {
 187   1        // Timer1 interrupt
 188   1        // TODO: add your code here
 189   1      }
 190          
 191          #if 0
              void INT_ADC() interrupt 18
              {
                // ADC interrupt
                // TODO: add your code here
              }
              #endif
 198          
 199          //======================================================
 200          // Peripheral setting routines
 201          //======================================================
 202          #if 0
              unsigned int ADC_read()
              {
                // read A/D convertor
                unsigned int adcVal;
                
                while(!(ADCCRL & 0x10));  // wait ADC busy
                adcVal = ADCDRH << 8; // read ADC high
                adcVal |= ADCDRL; // read ADC low
                ADCCRL &= ~0x80;  // disable ADC
                return  adcVal;
              }
              #endif
 215          
 216          void ADC_init()
 217          {
 218   1        // initialize A/D convertor
 219   1        PPCLKEN0 |= 0x40; // Enable clock for ADC
 220   1        ADCCRL = 0x00;    // setting
 221   1        ADCCRH = 0x0E;    // trigger source, alignment, frequency
 222   1        //IE3 |= 0x01;      // enable ADC interrupt
 223   1      }
 224          
 225          void ADC_start(unsigned char ch)
 226          {
 227   1        // start A/D convertor
 228   1        ADCCRL |= 0x80;   // enable ADC
 229   1        ADCCRL = (ADCCRL & 0xf0) | (ch & 0x0f); // select channel
 230   1        ADCCRL |= 0x40;   // start ADC
 231   1      }
 232          
 233          void ExINT_init()
 234          {
 235   1        // initialize external interrupt
 236   1        EIPOL2L = 0x0C;   // edge : external INT.10 ~ 12
 237   1        IE |= 0x02;       // Enable Ext.INT 10 ~ 12
 238   1      }
 239          
 240          #if UART_MAIN_PROC
C51 COMPILER V9.60.7.0   MAIN                                                              11/09/2025 17:18:29 PAGE 5   

 241          void LPUART_init()
 242          {
 243   1        // initialize LPUART
 244   1        PPCLKEN2 |= 0x80; // Enable clock for LPUART
 245   1      
 246   1        LPUT0CR0 = 0x06;  // Control 0
 247   1        LPUT0CR1 = 0x0D;  // Control 1
 248   1      
 249   1        // Set DE pin : Disabled
 250   1        LPUT0CR2 = 0x00;  // Active level start time (0.006500ms)
 251   1        LPUT0CR3 = 0x00;  // Active level finish time (0.006500ms)
 252   1        LPUT0CR4 = 0x00;  // Control 4
 253   1      
 254   1        // Set communication
 255   1        // - Source clock : fx
 256   1        // - Baudrate : 9600
 257   1        // - Data bit count : 8
 258   1        // - Stop bit count : 1
 259   1        // - Parity : No
 260   1        // - Oversampling : 16
 261   1        LPUT0BDR = 0x67;  // Baudrate
 262   1        LPUT0BCPH = 0x80; // Bit compensation High
 263   1        LPUT0BCPL = 0x49; // Bit compensation Low
 264   1        LPUT0RTDRH = 0xFF;  // Rx time out High (6815.744000ms)
 265   1        LPUT0RTDRL = 0xFF;  // Rx time out Low
 266   1        LPUT0RCDR = 0x00; // Rx character detection data
 267   1        LPUT0DLY = 0x00;  // Tx delay time (0.000000ms)
 268   1      }
 269          
 270          void LPUART_SendChar(unsigned char ch)
 271          {
 272   1          LPUT0TDR = ch;
 273   1      }
 274          
 275          void LPUART_SendStr(const char* str)
 276          {
 277   1        while(*str != '\0')
 278   1        {
 279   2          LPUART_SendChar(*str);
 280   2          delay_us(100);
 281   2          str++;
 282   2        }
 283   1      }
 284          
 285          void LPUART_SendNum(unsigned long num)
 286          {
 287   1        char buffer[12];
 288   1        int i = 0;
 289   1      
 290   1        if(num == 0)
 291   1        {
 292   2          LPUART_SendChar('0');
 293   2          return;
 294   2        }
 295   1      
 296   1        while(num > 0)
 297   1        {
 298   2          buffer[i++] = (num % 10) + '0';
 299   2          num /= 10;
 300   2        }
 301   1      
 302   1        while(i > 0)
C51 COMPILER V9.60.7.0   MAIN                                                              11/09/2025 17:18:29 PAGE 6   

 303   1        {
 304   2          LPUART_SendChar(buffer[--i]);
 305   2          delay_us(100);
 306   2        }
 307   1      }
 308          #endif
 309          
 310          void Timer0_init()
 311          {
 312   1        // initialize Timer0
 313   1        PPCLKEN1 |= 0x01; // Enable clock for Timer0
 314   1      
 315   1        // 16bit PWM0, period = 20.000000mS ( 50.000000Hz )
 316   1        //     PWM duty = 50.000000%
 317   1        T0CRH = 0x30;     // PWM setting High, repeat mode
 318   1        T0CRL = 0x20;     // PWM setting Low
 319   1        T0BDRH = 0x4E;    // duty High
 320   1        T0BDRL = 0x1F;    // duty Low
 321   1        T0ADRH = 0x9C;    // period count High
 322   1        T0ADRL = 0x3F;    // period count Low
 323   1        //T0CRL = 0x08;   // disable Timer reload signal
 324   1        IE2 |= 0x01;      // Enable Timer0 interrupt
 325   1      
 326   1        T0CRH |= 0x80;    // enable counter
 327   1      }
 328          
 329          void Timer0_SetPPGDutyCounter(uint16_t count)
 330          {
 331   1          T0BDRH = 0x00FF & (count >> 8);
 332   1          T0BDRL = 0x00FF & (count >> 0);
 333   1      }
 334          
 335          void Timer0_SetPPGPeriodCounter(uint16_t count)
 336          {
 337   1          T0ADRH = 0x00FF & (count >> 8);
 338   1          T0ADRL = 0x00FF & (count >> 0);
 339   1      }
 340          
 341          void Timer1_init()
 342          {
 343   1        // initialize Timer1
 344   1        PPCLKEN1 |= 0x02; // Enable clock for Timer1
 345   1      
 346   1        // 16bit capture1, period = 20.000000mS
 347   1        T1CRH = 0x10;     // capture setting High
 348   1        T1CRL = 0x60;     // capture setting Low
 349   1        T1ADRH = 0x9C;    // period count High
 350   1        T1ADRL = 0x3F;    // period count Low
 351   1        //T1CRL = 0x08;   // disable Timer reload signal
 352   1        IE2 |= 0x02;      // Enable Timer1 interrupt
 353   1      
 354   1        T1CRH |= 0x80;    // enable counter
 355   1      }
 356          
 357          uint16_t Timer1_GetCaptureValue(void) 
 358          {
 359   1        uint16_t count = 0;
 360   1        count = T1CAPL;
 361   1        count += (T1CAPH << 8);
 362   1        return count;
 363   1      }
 364          
C51 COMPILER V9.60.7.0   MAIN                                                              11/09/2025 17:18:29 PAGE 7   

 365          void Timer2_init()
 366          {
 367   1        // initialize Timer2
 368   1        PPCLKEN1 |= 0x04; // Enable clock for Timer2
 369   1      
 370   1        // 16bit PWM2, period = 20.000000mS ( 50.000000Hz )
 371   1        //     PWM duty = 50.000000%
 372   1        T2CRH = 0x30;     // PWM setting High, repeat mode
 373   1        T2CRL = 0x60;     // PWM setting Low
 374   1        T2BDRH = 0x4E;    // duty High
 375   1        T2BDRL = 0x1F;    // duty Low
 376   1        T2ADRH = 0x9C;    // period count High
 377   1        T2ADRL = 0x3F;    // period count Low
 378   1        //T2CRL = 0x08;   // disable Timer reload signal
 379   1        IE2 |= 0x04;      // Enable Timer2 interrupt
 380   1      
 381   1        T2CRH |= 0x80;    // enable counter
 382   1      }
 383          
 384          void clock_init()
 385          {
 386   1        // HFIRC clock (16.000000MHz)
 387   1        unsigned char tmp;  // variable for HFIRC
 388   1      
 389   1        tmp = OSCCR;      // get default
 390   1        tmp &= ~(0x07 << 3);  // clear divider
 391   1        tmp |= 0x28;      // set divider
 392   1        OSCCR = tmp;      // Set HFIRC
 393   1        SCCR = 0x00;      // Use HFIRC
 394   1      }
 395          
 396          void port_init()
 397          {
 398   1        // initialize ports
 399   1        // Initialize P0x ports
 400   1        PPCLKEN0 |= 0x01; // Enable clock for P0x ports
 401   1        P0PU = 0x00;      // pullup
 402   1        P0OD = 0x00;      // open drain
 403   1        P0IOH = 0xAA;     // direction High
 404   1        P0IOL = 0x2A;     // direction Low
 405   1        P0DB = 0x08;      // bit7~6 = debounce clock
 406   1        P0 = 0x00;        // port initial value
 407   1        P0FSRH = 0x18;    // P0 selection High
 408   1        P0FSRL = 0x10;    // P0 selection Low
 409   1      
 410   1        // Initialize P1x ports
 411   1        PPCLKEN0 |= 0x02; // Enable clock for P1x ports
 412   1        P1PU = 0x00;      // pullup
 413   1        P1OD = 0x00;      // open drain
 414   1        P1IOH = 0xAA;     // direction High
 415   1        //P1IOL = 0xAA;     // direction Low
 416   1        P1IOL = 0x96;
 417   1        P1DB = 0x00;      // debounce
 418   1        P1 = 0x00;        // port initial value
 419   1        P1FSRH = 0x00;    // P1 selection High
 420   1        P1FSRL = 0x00;    // P1 selection Low
 421   1      
 422   1        // Initialize P2x ports
 423   1        PPCLKEN0 |= 0x04; // Enable clock for P2x ports
 424   1        P2PU = 0x00;      // pullup
 425   1        P2OD = 0x00;      // open drain
 426   1        P2IOL = 0xAA;     // direction Low
C51 COMPILER V9.60.7.0   MAIN                                                              11/09/2025 17:18:29 PAGE 8   

 427   1        P2 = 0x00;        // port initial value
 428   1        P2FSRL = 0x00;    // P2 selection Low
 429   1      }
 430          
 431          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1128    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     30      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
